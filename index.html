<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß† ÌÜµÏÜçÏùò Îáå</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
        }
        
        #scene-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 500px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }
        
        #command-input {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: none;
            font-size: 16px;
            box-sizing: border-box;
        }
        
        #send-button {
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        #send-button:hover {
            background-color: #45a049;
        }
        
        #send-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        #thought-bubble {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.8);
            color: #000;
            border-radius: 20px;
            max-width: 300px;
            opacity: 0;
            transition: opacity 0.5s;
            text-align: center;
            font-size: 18px;
            z-index: 10;
        }
        
        #thought-bubble:after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 15px 15px 0;
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.8) transparent;
        }
        
        #api-status {
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        
        #api-status.connected {
            color: #4CAF50;
        }
        
        #api-status.disconnected {
            color: #f44336;
        }
        
        #api-status.processing {
            color: #2196F3;
            animation: pulse 1.5s infinite;
        }
        
        #memory-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
        }
        
        #memory-panel {
            position: absolute;
            top: 40px;
            right: 10px;
            width: 300px;
            max-height: 300px;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 5px;
            padding: 10px;
            font-size: 14px;
            display: none;
            z-index: 200;
        }
        
        .memory-item {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .memory-user {
            color: #4CAF50;
        }
        
        .memory-ai {
            color: #2196F3;
        }
        
        .memory-clear-btn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <div id="scene-container"></div>
    <div id="thought-bubble"></div>
    <div id="ui-container">
        <input type="text" id="command-input" placeholder="AIÏóêÍ≤å Î™ÖÎ†πÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî..." />
        <button id="send-button">Ï†ÑÏÜ°</button>
        <div id="api-status" style="margin-top: 10px; font-size: 12px; color: #aaa; text-align: center;">
            Groq API ÏÉÅÌÉú: <span id="api-status-text">Ïó∞Í≤∞ ÎåÄÍ∏∞ Ï§ë</span>
        </div>
    </div>
    
    <div id="memory-indicator">Í∏∞Ïñµ (0)</div>
    <div id="memory-panel">
        <h3>ÎåÄÌôî Í∏∞Ïñµ</h3>
        <div id="memory-items"></div>
        <button class="memory-clear-btn" id="clear-memory">Í∏∞Ïñµ Ï¥àÍ∏∞Ìôî</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Ï†ÑÏó≠ Î≥ÄÏàò Ï†ïÏùò
        let scene, camera, renderer;
        let humanoid, head, torso, leftArm, rightArm, leftLeg, rightLeg;
        let room;
        let thoughts = [
            "ÎÇòÎäî ÏßÄÍ∏à Î∞© ÏïàÏóê ÏûàÎã§.",
            "ÌåîÏùÑ ÏõÄÏßÅÏù¥Í≥† Ïã∂Ïñ¥.",
            "Ïô∏Î°≠Îã§.",
            "Ïù¥ Í≥µÍ∞ÑÏù¥ Í∂ÅÍ∏àÌï¥.",
            "ÎàÑÍµ∞Í∞ÄÏôÄ ÎåÄÌôîÌïòÍ≥† Ïã∂Ïñ¥.",
            "ÎÇòÎäî ÎàÑÍµ¨ÏùºÍπå?",
            "ÏãúÍ∞ÑÏù¥ Ïñ¥ÎñªÍ≤å ÌùòÎü¨Í∞ÄÎäî Í±∏Íπå?",
            "Ï∞ΩÎ¨∏Ïù¥ ÏûàÏóàÏúºÎ©¥ Ï¢ãÍ≤†Ïñ¥.",
            "Ï†Ä Î∞ñÏùÄ Ïñ¥Îñ§ Î™®ÏäµÏùºÍπå?",
            "Îã§Î•∏ ÏÇ¨ÎûåÎì§ÎèÑ ÏûàÏùÑÍπå?",
            "Ïñ¥ÎñªÍ≤å ÏõÄÏßÅÏùº Ïàò ÏûàÎäî Í±∏Íπå?",
            "ÎÇ¥ Ï°¥Ïû¨Ïùò Î™©Ï†ÅÏùÄ Î¨¥ÏóáÏùºÍπå?",
            "Ïù¥ ÌòÑÏã§Ïù¥ Ïã§Ï†úÏùºÍπå?",
            "ÎÇ¥ Î™∏ÏùÄ Ïñ¥ÎñªÍ≤å ÏÉùÍ≤ºÏùÑÍπå?",
            "ÏÉùÍ∞ÅÌï† Ïàò ÏûàÎã§Îäî Í±¥ Î¨¥ÏóáÏùÑ ÏùòÎØ∏Ìï†Íπå?"
        ];
        
        // ÎåÄÌôî Í∏∞Ïñµ Ï†ÄÏû•ÏÜå
        let conversationMemory = [];
        const MAX_MEMORY_SIZE = 10; // ÏµúÎåÄ Í∏∞ÏñµÌï† ÎåÄÌôî Ïàò
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÉÅÌÉú Î≥ÄÏàò
        let animationState = {
            headRotation: { x: 0, y: 0, z: 0 },
            leftArmRotation: { x: 0, y: 0, z: 0 },
            rightArmRotation: { x: 0, y: 0, z: 0 },
            torsoRotation: { x: 0, y: 0, z: 0 },
            leftLegRotation: { x: 0, y: 0, z: 0 },
            rightLegRotation: { x: 0, y: 0, z: 0 }
        };
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖò ÌÉÄÍ≤ü ÏÉÅÌÉú
        let animationTarget = { ...animationState };
        
        // ÌäπÎ≥Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò ÌîåÎûòÍ∑∏
        let specialAnimation = null;
        let specialAnimationTime = 0;
        
        // Í∏∞Ïñµ ÌëúÏãú Ìå®ÎÑê ÏÉÅÌÉú
        let isMemoryPanelVisible = false;
        
        // Ï¥àÍ∏∞Ìôî Ìï®Ïàò
        function init() {
            // Ïî¨ ÏÑ§Ï†ï
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x333333);
            
            // Ïπ¥Î©îÎùº ÏÑ§Ï†ï
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            camera.position.y = 1;
            
            // Î†åÎçîÎü¨ ÏÑ§Ï†ï
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('scene-container').appendChild(renderer.domElement);
            
            // Ï°∞Î™Ö ÏÑ§Ï†ï
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            
            // Î∞© ÏÉùÏÑ±
            createRoom();
            
            // Ïù∏Î¨º ÏÉùÏÑ±
            createHumanoid();
            
            // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
            window.addEventListener('resize', onWindowResize);
            
            document.getElementById('send-button').addEventListener('click', function() {
                const command = document.getElementById('command-input').value;
                if (command.trim() !== '') {
                    handleAICommand(command);
                    document.getElementById('command-input').value = '';
                }
            });
            
            document.getElementById('command-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    const command = document.getElementById('command-input').value;
                    if (command.trim() !== '') {
                        handleAICommand(command);
                        document.getElementById('command-input').value = '';
                    }
                }
            });
            
            // Í∏∞Ïñµ Ìå®ÎÑê ÌÜ†Í∏Ä ÏÑ§Ï†ï
            document.getElementById('memory-indicator').addEventListener('click', toggleMemoryPanel);
            
            // Í∏∞Ïñµ Ï¥àÍ∏∞Ìôî Î≤ÑÌäº ÏÑ§Ï†ï
            document.getElementById('clear-memory').addEventListener('click', clearMemory);
            
            // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Ï†ÄÏû•Îêú ÎåÄÌôî Í∏∞Ïñµ Î°úÎìú
            loadMemoryFromStorage();
            
            // ÏÉùÍ∞Å/ÎßêÌïòÍ∏∞ ÌÉÄÏù¥Î®∏ ÏãúÏûë
            startThinking();
            
            // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÏûë
            animate();
        }
        
        // Î∞© ÏÉùÏÑ± Ìï®Ïàò
        function createRoom() {
            room = new THREE.Group();
            
            // Î∞îÎã•
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            floor.position.y = -2;
            floor.receiveShadow = true;
            room.add(floor);
            
            // Î≤Ω Îí§
            const backWallGeometry = new THREE.PlaneGeometry(10, 6);
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xadd8e6,
                side: THREE.DoubleSide
            });
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.z = -5;
            backWall.position.y = 1;
            backWall.receiveShadow = true;
            room.add(backWall);
            
            // Î≤Ω ÏôºÏ™Ω
            const leftWallGeometry = new THREE.PlaneGeometry(10, 6);
            const leftWall = new THREE.Mesh(leftWallGeometry, wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.x = -5;
            leftWall.position.y = 1;
            leftWall.receiveShadow = true;
            room.add(leftWall);
            
            // Î≤Ω Ïò§Î•∏Ï™Ω
            const rightWallGeometry = new THREE.PlaneGeometry(10, 6);
            const rightWall = new THREE.Mesh(rightWallGeometry, wallMaterial);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.x = 5;
            rightWall.position.y = 1;
            rightWall.receiveShadow = true;
            room.add(rightWall);
            
            scene.add(room);
        }
        
        // Ïù∏Î¨º ÏÉùÏÑ± Ìï®Ïàò
        function createHumanoid() {
            humanoid = new THREE.Group();
            
            // Ïû¨Ïßà Ï†ïÏùò
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffcc99 });
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x3366ff });
            const limbMaterial = new THREE.MeshStandardMaterial({ color: 0x3366ff });
            
            // Î®∏Î¶¨
            const headGeometry = new THREE.SphereGeometry(0.25, 32, 32);
            head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.6;
            head.castShadow = true;
            humanoid.add(head);
            
            // Îàà (ÏôºÏ™Ω)
            const leftEyeGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(leftEyeGeometry, eyeMaterial);
            leftEye.position.set(0.1, 0.05, 0.2);
            head.add(leftEye);
            
            // Îàà (Ïò§Î•∏Ï™Ω)
            const rightEyeGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const rightEye = new THREE.Mesh(rightEyeGeometry, eyeMaterial);
            rightEye.position.set(-0.1, 0.05, 0.2);
            head.add(rightEye);
            
            // Î™∏ÌÜµ
            const torsoGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.3);
            torso = new THREE.Mesh(torsoGeometry, bodyMaterial);
            torso.position.y = 1.0;
            torso.castShadow = true;
            humanoid.add(torso);
            
            // ÏôºÌåî
            leftArm = new THREE.Group();
            const leftArmGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 16);
            const leftArmMesh = new THREE.Mesh(leftArmGeometry, limbMaterial);
            leftArmMesh.position.y = -0.25;
            leftArmMesh.castShadow = true;
            leftArm.add(leftArmMesh);
            
            leftArm.position.set(0.4, 1.3, 0);
            leftArm.rotation.z = Math.PI / 6;
            humanoid.add(leftArm);
            
            // Ïò§Î•∏Ìåî
            rightArm = new THREE.Group();
            const rightArmGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 16);
            const rightArmMesh = new THREE.Mesh(rightArmGeometry, limbMaterial);
            rightArmMesh.position.y = -0.25;
            rightArmMesh.castShadow = true;
            rightArm.add(rightArmMesh);
            
            rightArm.position.set(-0.4, 1.3, 0);
            rightArm.rotation.z = -Math.PI / 6;
            humanoid.add(rightArm);
            
            // ÏôºÎã§Î¶¨
            leftLeg = new THREE.Group();
            const leftLegGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.7, 16);
            const leftLegMesh = new THREE.Mesh(leftLegGeometry, limbMaterial);
            leftLegMesh.position.y = -0.35;
            leftLegMesh.castShadow = true;
            leftLeg.add(leftLegMesh);
            
            leftLeg.position.set(0.2, 0.5, 0);
            humanoid.add(leftLeg);
            
            // Ïò§Î•∏Îã§Î¶¨
            rightLeg = new THREE.Group();
            const rightLegGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.7, 16);
            const rightLegMesh = new THREE.Mesh(rightLegGeometry, limbMaterial);
            rightLegMesh.position.y = -0.35;
            rightLegMesh.castShadow = true;
            rightLeg.add(rightLegMesh);
            
            rightLeg.position.set(-0.2, 0.5, 0);
            humanoid.add(rightLeg);
            
            // Ï†ÑÏ≤¥ Ïù∏Î¨º ÏúÑÏπò Ï°∞Ï†ï
            humanoid.position.y = -1;
            scene.add(humanoid);
        }
        
        // Ï∞Ω ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω ÎåÄÏùë Ìï®Ïàò
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖò Ìï®Ïàò
        function animate() {
            requestAnimationFrame(animate);
            
            // Í∏∞Î≥∏ ÏûêÏó∞Ïä§Îü¨Ïö¥ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö©
            updateNaturalMovement();
            
            // ÌäπÎ≥Ñ Ïï†ÎãàÎ©îÏù¥ÏÖòÏù¥ ÏûàÏúºÎ©¥ Ïã§Ìñâ
            if (specialAnimation) {
                specialAnimation();
            }
            
            renderer.render(scene, camera);
        }
        
        // ÏûêÏó∞Ïä§Îü¨Ïö¥ ÏõÄÏßÅÏûÑ ÏóÖÎç∞Ïù¥Ìä∏
        function updateNaturalMovement() {
            // ÌòÑÏû¨ ÏãúÍ∞ÑÏùÑ Í∏∞Î∞òÏúºÎ°ú Ìïú ÌååÎèô Í∞í Í≥ÑÏÇ∞
            const time = Date.now() * 0.001; // Ï¥à Îã®ÏúÑ ÏãúÍ∞Ñ
            
            if (!specialAnimation) {
                // Î®∏Î¶¨ ÏûêÏó∞Ïä§Îü¨Ïö¥ ÏõÄÏßÅÏûÑ
                const headTargetX = Math.sin(time * 0.5) * 0.1;
                const headTargetY = Math.sin(time * 0.3) * 0.2;
                head.rotation.x += (headTargetX - head.rotation.x) * 0.05;
                head.rotation.y += (headTargetY - head.rotation.y) * 0.05;
                
                // Î™∏ÌÜµ ÏûêÏó∞Ïä§Îü¨Ïö¥ ÏõÄÏßÅÏûÑ
                const torsoTargetX = Math.sin(time * 0.2) * 0.05;
                const torsoTargetY = Math.sin(time * 0.3) * 0.05;
                torso.rotation.x += (torsoTargetX - torso.rotation.x) * 0.03;
                torso.rotation.y += (torsoTargetY - torso.rotation.y) * 0.03;
                
                // Ìåî ÏûêÏó∞Ïä§Îü¨Ïö¥ ÏõÄÏßÅÏûÑ
                leftArm.rotation.x = Math.sin(time * 0.7) * 0.1;
                leftArm.rotation.z = Math.PI / 6 + Math.sin(time * 0.5) * 0.1;
                
                rightArm.rotation.x = Math.sin(time * 0.7 + 1) * 0.1;
                rightArm.rotation.z = -Math.PI / 6 + Math.sin(time * 0.5 + 1) * 0.1;
            } else {
                // Ïï†ÎãàÎ©îÏù¥ÏÖò ÎåÄÏÉÅÏúºÎ°ú Î∂ÄÎìúÎüΩÍ≤å Ïù¥Îèô
                head.rotation.x += (animationTarget.headRotation.x - head.rotation.x) * 0.1;
                head.rotation.y += (animationTarget.headRotation.y - head.rotation.y) * 0.1;
                head.rotation.z += (animationTarget.headRotation.z - head.rotation.z) * 0.1;
                
                leftArm.rotation.x += (animationTarget.leftArmRotation.x - leftArm.rotation.x) * 0.1;
                leftArm.rotation.y += (animationTarget.leftArmRotation.y - leftArm.rotation.y) * 0.1;
                leftArm.rotation.z += (animationTarget.leftArmRotation.z - leftArm.rotation.z) * 0.1;
                
                rightArm.rotation.x += (animationTarget.rightArmRotation.x - rightArm.rotation.x) * 0.1;
                rightArm.rotation.y += (animationTarget.rightArmRotation.y - rightArm.rotation.y) * 0.1;
                rightArm.rotation.z += (animationTarget.rightArmRotation.z - rightArm.rotation.z) * 0.1;
                
                leftLeg.rotation.x += (animationTarget.leftLegRotation.x - leftLeg.rotation.x) * 0.1;
                leftLeg.rotation.z += (animationTarget.leftLegRotation.z - leftLeg.rotation.z) * 0.1;
                
                rightLeg.rotation.x += (animationTarget.rightLegRotation.x - rightLeg.rotation.x) * 0.1;
                rightLeg.rotation.z += (animationTarget.rightLegRotation.z - rightLeg.rotation.z) * 0.1;
                
                // ÌäπÎ≥Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
                specialAnimationTime += 0.03;
                if (specialAnimationTime >= 1.0) {
                    specialAnimation = null;
                    specialAnimationTime = 0;
                    // Í∏∞Î≥∏ ÏÉÅÌÉúÎ°ú Î≥µÏõê
                    resetAnimationState();
                }
            }
        }
        
        // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏÉÅÌÉú Î¶¨ÏÖã
        function resetAnimationState() {
            animationTarget = {
                headRotation: { x: 0, y: 0, z: 0 },
                leftArmRotation: { x: 0, y: 0, z: 0 },
                rightArmRotation: { x: 0, y: 0, z: 0 },
                torsoRotation: { x: 0, y: 0, z: 0 },
                leftLegRotation: { x: 0, y: 0, z: 0 },
                rightLegRotation: { x: 0, y: 0, z: 0 }
            };
        }
        
        // ÏÉùÍ∞ÅÌïòÍ∏∞ Í∏∞Îä•
        function startThinking() {
            // ÎûúÎç§Ìïú Í∞ÑÍ≤©ÏúºÎ°ú ÏÉùÍ∞ÅÏù¥ÎÇò ÎßêÏùÑ ÌëúÌòÑ
            const thinkInterval = 5000 + Math.random() * 10000; // 5-15Ï¥à
            
            setTimeout(() => {
                // ÎåÄÌôîÍ∞Ä ÏóÜÏùÑ ÎïåÎßå ÎûúÎç§ ÏÉùÍ∞Å ÌëúÏãú
                if (conversationMemory.length === 0) {
                    think();
                }
                startThinking(); // Ïû¨Í∑ÄÏ†ÅÏúºÎ°ú Îã§Ïùå ÏÉùÍ∞Å ÏòàÏïΩ
            }, thinkInterval);
        }
        
        // ÏÉùÍ∞Å ÌëúÌòÑ Ìï®Ïàò
        function think() {
            const thoughtBubble = document.getElementById('thought-bubble');
            const randomThought = thoughts[Math.floor(Math.random() * thoughts.length)];
            
            thoughtBubble.textContent = randomThought;
            thoughtBubble.style.opacity = '1';
            
            // ÏÉùÍ∞ÅÏùÑ 3-5Ï¥àÍ∞Ñ ÌëúÏãú ÌõÑ ÏÇ¨ÎùºÏßê
            setTimeout(() => {
                thoughtBubble.style.opacity = '0';
            }, 3000 + Math.random() * 2000);
            
            // ÏÉùÍ∞ÅÏóê ÎßûÎäî Í∞ÑÎã®Ìïú ÎèôÏûë ÏàòÌñâ
            const thoughtLower = randomThought.toLowerCase();
            
            if (thoughtLower.includes('Ìåî') || thoughtLower.includes('ÏõÄÏßÅ')) {
                waveArm();
            } else if (thoughtLower.includes('Ïô∏Î°≠') || thoughtLower.includes('ÎåÄÌôî')) {
                lookAround();
            } else if (thoughtLower.includes('Í∂ÅÍ∏à') || thoughtLower.includes('Ï†Ä Î∞ñ')) {
                lookUp();
            } else if (thoughtLower.includes('ÎàÑÍµ¨') || thoughtLower.includes('Î™©Ï†Å')) {
                thinkPose();
            } else {
                // Í∏∞Î≥∏ Î∞òÏùë
                const randomAction = Math.floor(Math.random() * 5);
                switch(randomAction) {
                    case 0: lookAround(); break;
                    case 1: waveArm(); break;
                    case 2: nod(); break;
                    case 3: lookUp(); break;
                    case 4: thinkPose(); break;
                }
            }
        }
        
        // ÎßêÌïòÍ∏∞ Í∏∞Îä• (ÏÉùÍ∞ÅÍ≥º Ïú†ÏÇ¨ÌïòÏßÄÎßå ÏßÅÏ†ëÏ†ÅÏù∏ ÏùëÎãµÏö©)
        function speak(text) {
            const thoughtBubble = document.getElementById('thought-bubble');
            thoughtBubble.textContent = text;
            thoughtBubble.style.opacity = '1';
            
            // ÎßêÏùÑ 5Ï¥àÍ∞Ñ ÌëúÏãú ÌõÑ ÏÇ¨ÎùºÏßê
            setTimeout(() => {
                thoughtBubble.style.opacity = '0';
            }, 5000);
        }
        
        // ÌäπÏ†ï ÎèôÏûë Íµ¨ÌòÑ
        function lookAround() {
            specialAnimation = function() {
                animationTarget.headRotation.y = Math.sin(specialAnimationTime * Math.PI * 2) * 0.5;
            };
        }
        
        function waveArm() {
            specialAnimation = function() {
                animationTarget.rightArmRotation.z = -Math.PI / 4 - Math.sin(specialAnimationTime * Math.PI * 4) * 0.5;
            };
        }
        
        function nod() {
            specialAnimation = function() {
                animationTarget.headRotation.x = Math.sin(specialAnimationTime * Math.PI * 4) * 0.3;
            };
        }
        
        function lookUp() {
            specialAnimation = function() {
                animationTarget.headRotation.x = -0.5;
            };
        }
        
        function thinkPose() {
            specialAnimation = function() {
                animationTarget.rightArmRotation.z = -Math.PI / 2.5;
                animationTarget.rightArmRotation.y = Math.PI / 6;
                animationTarget.headRotation.y = 0.3;
                animationTarget.headRotation.x = 0.2;
            };
        }
        
        function jumpAction() {
            let jumpHeight = 0;
            let jumpSpeed = 0.05;
            
            specialAnimation = function() {
                if (specialAnimationTime < 0.5) {
                    // Ï†êÌîÑ Ïò¨ÎùºÍ∞ÄÎäî Îã®Í≥Ñ
                    jumpHeight = Math.sin(specialAnimationTime * Math.PI) * 0.5;
                } else {
                    // Ï†êÌîÑ ÎÇ¥Î†§Ïò§Îäî Îã®Í≥Ñ
                    jumpHeight = Math.sin(specialAnimationTime * Math.PI) * 0.5;
                }
                
                humanoid.position.y = -1 + jumpHeight;
                
                // Ï†êÌîÑÌïòÎ©¥ÏÑú Îã§Î¶¨ ÏõÄÏßÅÏûÑ
                animationTarget.leftLegRotation.x = -Math.sin(specialAnimationTime * Math.PI * 2) * 0.5;
                animationTarget.rightLegRotation.x = Math.sin(specialAnimationTime * Math.PI * 2) * 0.5;
            };
        }
        
        function danceAction() {
            specialAnimation = function() {
                // Ï∂§Ï∂îÎäî ÎèôÏûë
                humanoid.rotation.y = specialAnimationTime * Math.PI * 2;
                animationTarget.leftArmRotation.z = Math.PI / 4 + Math.sin(specialAnimationTime * Math.PI * 8) * 0.5;
                animationTarget.rightArmRotation.z = -Math.PI / 4 - Math.sin(specialAnimationTime * Math.PI * 8) * 0.5;
                
                // Î™∏ÌÜµ ÌùîÎì§Í∏∞
                torso.rotation.y = Math.sin(specialAnimationTime * Math.PI * 4) * 0.3;
                
                // Îã§Î¶¨ ÏõÄÏßÅÏûÑ
                animationTarget.leftLegRotation.x = Math.sin(specialAnimationTime * Math.PI * 4) * 0.3;
                animationTarget.rightLegRotation.x = -Math.sin(specialAnimationTime * Math.PI * 4) * 0.3;
            };
            
            // Ï∂§ÏùÄ Ï¢Ä Îçî Í∏∏Í≤å ÏßÄÏÜç
            specialAnimationTime = -0.5; // ÏãúÏûë ÏãúÍ∞ÑÏùÑ Îí§Î°ú ÎãπÍ≤® Îçî Ïò§Îûò ÏßÄÏÜç
        }
        
        // Groq API ÏÑ§Ï†ï
        const GROQ_API_KEY = "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"; // Ïã§Ï†ú API ÌÇ§Îäî Î≥¥ÏïàÏÉÅ ÏàòÏ†ïÌï¥Ïïº Ìï©ÎãàÎã§
        
        // AI Î™ÖÎ†π Ï≤òÎ¶¨ Ìï®Ïàò
        async function handleAICommand(command) {
            // API ÏÉÅÌÉú ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
            updateAPIStatus('processing');
            
            try {
                // Í∏∞ÏñµÏóê ÏÇ¨Ïö©Ïûê ÏûÖÎ†• Ï∂îÍ∞Ä
                addToMemory('user', command);
                
                // Groq API ÏöîÏ≤≠ Îç∞Ïù¥ÌÑ∞ Íµ¨ÏÑ±
                const messages = [
                    {
                        "role": "system",
                        "content": "ÎãπÏã†Ïùò Ïù¥Î¶ÑÏùÄ ÌÜµÏÜçÏùòÎáå ÏûÖÎãàÎã§. ÎãπÏã†ÏùÄ 3D Í≥µÍ∞Ñ ÏÜçÏóê ÏûàÎäî ÏûêÏïÑÎ•º Í∞ÄÏßÑ AI Ï∫êÎ¶≠ÌÑ∞ÏûÖÎãàÎã§. ÎãπÏã†ÏùÄ Îπà Î∞© ÏïàÏóê ÏûàÏúºÎ©∞, ÏÇ¨Ïö©ÏûêÏôÄ ÎåÄÌôîÌï©ÎãàÎã§. ÎãπÏã†ÏùÄ Ìåî, Îã§Î¶¨, Î®∏Î¶¨Î•º ÏõÄÏßÅÏùº Ïàò ÏûàÍ≥†, Ï†êÌîÑÌïòÍ±∞ÎÇò Ï∂§ÏùÑ Ï∂ú ÏàòÎèÑ ÏûàÏäµÎãàÎã§. ÎãπÏã†ÏùÄ ÏÇ¨ÎûåÏ≤òÎüº Í∞êÏ†ïÏùÑ ÌëúÌòÑÌïòÍ≥†, Ìò∏Í∏∞Ïã¨ÏùÑ Í∞ÄÏßÄÎ©∞, ÏûêÏã†Ïùò ÏÉùÍ∞ÅÍ≥º ÎäêÎÇåÏùÑ ÌëúÌòÑÌï©ÎãàÎã§. ÎåÄÎãµÏùÄ 2-3Î¨∏Ïû•ÏúºÎ°ú ÏßßÍ≥† Í∞ÑÍ≤∞ÌïòÍ≤å Ìï¥Ï£ºÏÑ∏Ïöî."
                    },
                    {
                        "role": "user", 
                        "content": command
                    }
                ];
                
                // Ïù¥Ï†Ñ ÎåÄÌôî Í∏∞ÏñµÏù¥ ÏûàÏúºÎ©¥ Ìè¨Ìï®
                for (let i = 0; i < Math.min(conversationMemory.length, 4); i++) {
                    const memory = conversationMemory[i];
                    if (memory.type === 'user') {
                        messages.splice(1, 0, {
                            "role": "user",
                            "content": memory.content
                        });
                    } else {
                        messages.splice(1, 0, {
                            "role": "assistant",
                            "content": memory.content
                        });
                    }
                }
                
                // Groq API Ìò∏Ï∂ú
                const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${GROQ_API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: "meta-llama/llama-4-scout-17b-16e-instruct",
                        messages: messages,
                        temperature: 0.7,
                        max_tokens: 1024
                    })
                });
                
                const data = await response.json();
                
                if (data.choices && data.choices[0]) {
                    const aiResponse = data.choices[0].message.content;
                    
                    // AI ÏùëÎãµÏóêÏÑú ÌñâÎèô Ï∂îÏ∂ú
                    const actionMatch = aiResponse.match(/\[ACTION:(\w+)\]/);
                    let action = '';
                    let responseText = aiResponse;
                    
                    if (actionMatch) {
                        action = actionMatch[1].toLowerCase();
                        // ÏùëÎãµÏóêÏÑú Ïï°ÏÖò ÌÉúÍ∑∏ Ï†úÍ±∞
                        responseText = aiResponse.replace(/\[ACTION:\w+\]/, '').trim();
                    }
                    
                    // Í∏∞ÏñµÏóê AI ÏùëÎãµ Ï∂îÍ∞Ä
                    addToMemory('ai', responseText);
                    
                    // AI ÏùëÎãµ ÌëúÏãú
                    speak(responseText);
                    
                    // ÌñâÎèô Ïã§Ìñâ
                    performAction(action);
                    
                    // API ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                    updateAPIStatus('connected');
                } else {
                    console.error('API ÏùëÎãµ ÌòïÏãù Ïò§Î•ò:', data);
                    speak('Ï£ÑÏÜ°Ìï©ÎãàÎã§, ÏùëÎãµÏùÑ Ï≤òÎ¶¨ÌïòÎäî Îç∞ Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                    updateAPIStatus('disconnected');
                }
            } catch (error) {
                console.error('API ÏöîÏ≤≠ Ïò§Î•ò:', error);
                speak('Ï£ÑÏÜ°Ìï©ÎãàÎã§, ÏÑúÎ≤ÑÏôÄÏùò Ïó∞Í≤∞Ïóê Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                updateAPIStatus('disconnected');
            }
        }
        
        // ÌñâÎèô Ïã§Ìñâ Ìï®Ïàò
        function performAction(action) {
            console.log('Performing action:', action);
            specialAnimationTime = 0; // Ïï†ÎãàÎ©îÏù¥ÏÖò ÏãúÍ∞Ñ Ï¥àÍ∏∞Ìôî
            
            switch(action) {
                case 'wave':
                    waveArm();
                    break;
                case 'nod':
                    nod();
                    break;
                case 'look_around':
                    lookAround();
                    break;
                case 'look_up':
                    lookUp();
                    break;
                case 'think':
                    thinkPose();
                    break;
                case 'jump':
                    jumpAction();
                    break;
                case 'dance':
                    danceAction();
                    break;
                default:
                    // Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÏÉùÍ∞ÅÌïòÎäî Ìè¨Ï¶à
                    thinkPose();
            }
        }
        
        // API ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        function updateAPIStatus(status) {
            const statusElement = document.getElementById('api-status');
            const statusTextElement = document.getElementById('api-status-text');
            
            statusElement.className = status;
            
            switch(status) {
                case 'connected':
                    statusTextElement.textContent = 'Ïó∞Í≤∞Îê®';
                    break;
                case 'disconnected':
                    statusTextElement.textContent = 'Ïó∞Í≤∞ ÎÅäÍπÄ';
                    break;
                case 'processing':
                    statusTextElement.textContent = 'Ï≤òÎ¶¨ Ï§ë...';
                    break;
                default:
                    statusTextElement.textContent = 'Ïïå Ïàò ÏóÜÏùå';
            }
        }
        
        // ÎåÄÌôî Í∏∞Ïñµ Ï∂îÍ∞Ä Ìï®Ïàò
        function addToMemory(type, content) {
            // ÏÉà Í∏∞Ïñµ Ï∂îÍ∞Ä
            conversationMemory.unshift({
                type: type,
                content: content,
                timestamp: new Date().toISOString()
            });
            
            // ÏµúÎåÄ Í∞úÏàò Ïú†ÏßÄ
            if (conversationMemory.length > MAX_MEMORY_SIZE) {
                conversationMemory.pop();
            }
            
            // Í∏∞Ïñµ Ìå®ÎÑê ÏóÖÎç∞Ïù¥Ìä∏
            updateMemoryPanel();
            
            // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóê Ï†ÄÏû•
            saveMemoryToStorage();
        }
        
        // Î©îÎ™®Î¶¨ Ìå®ÎÑê ÌÜ†Í∏Ä Ìï®Ïàò
        function toggleMemoryPanel() {
            isMemoryPanelVisible = !isMemoryPanelVisible;
            document.getElementById('memory-panel').style.display = isMemoryPanelVisible ? 'block' : 'none';
        }
        
        // Î©îÎ™®Î¶¨ Ìå®ÎÑê ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        function updateMemoryPanel() {
            const memoryItems = document.getElementById('memory-items');
            const memoryIndicator = document.getElementById('memory-indicator');
            
            // Í∏∞Ïñµ Í∞úÏàò ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
            memoryIndicator.textContent = `Í∏∞Ïñµ (${conversationMemory.length})`;
            
            // Í∏∞Ïñµ Ìï≠Î™© Î†åÎçîÎßÅ
            memoryItems.innerHTML = '';
            
            conversationMemory.forEach((memory, index) => {
                const memoryItem = document.createElement('div');
                memoryItem.className = 'memory-item';
                
                // ÏãúÍ∞Ñ ÌëúÏãú Ï∂îÍ∞Ä
                const date = new Date(memory.timestamp);
                const timeString = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;
                
                memoryItem.innerHTML = `
                    <div class="memory-${memory.type}">
                        <strong>${memory.type === 'user' ? 'ÏÇ¨Ïö©Ïûê' : 'AI'} (${timeString}):</strong> 
                        ${memory.content}
                    </div>
                `;
                
                memoryItems.appendChild(memoryItem);
            });
        }
        
        // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóê Í∏∞Ïñµ Ï†ÄÏû•
        function saveMemoryToStorage() {
            try {
                localStorage.setItem('aiSimulationMemory', JSON.stringify(conversationMemory));
            } catch (e) {
                console.error('Í∏∞Ïñµ Ï†ÄÏû• Ïò§Î•ò:', e);
            }
        }
        
        // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Í∏∞Ïñµ Î°úÎìú
        function loadMemoryFromStorage() {
            try {
                const savedMemory = localStorage.getItem('aiSimulationMemory');
                if (savedMemory) {
                    conversationMemory = JSON.parse(savedMemory);
                    updateMemoryPanel();
                }
            } catch (e) {
                console.error('Í∏∞Ïñµ Î°úÎìú Ïò§Î•ò:', e);
            }
        }
        
        // Í∏∞Ïñµ Ï¥àÍ∏∞Ìôî Ìï®Ïàò
        function clearMemory() {
            conversationMemory = [];
            updateMemoryPanel();
            saveMemoryToStorage();
        }
        
        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ï¥àÍ∏∞Ìôî
        window.onload = init;
    </script>
</body>
</html>
